/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var vm = require( 'vm' );
var dirname = require( 'path' ).dirname;
var replace = require( '@stdlib/string/replace' );
var namespace = require( '@stdlib/namespace' );
var hasOwnProp = require( '@stdlib/assert/has-own-property' );
var compareValues = require( '@stdlib/_tools/doctest/compare-values' );


// VARIABLES //

var RE_EXTERNAL_ALIAS = /{{alias:([\s\S]+?)}}/g;
var RE_ASSIGNMENT = /(?:var|let|const)? ?([a-zA-Z0-9]*) ?=/;
var NAMESPACE = namespace();


// FUNCTIONS //

/**
* Returns an alias for a given package name.
*
* @private
* @param {string} pkg - package name
* @returns {(string|null)} alias name or null
*/
function pkg2alias( pkg ) {
	var alias;
	var i;

	for ( i = 0; i < NAMESPACE.length; i++ ) {
		if ( pkg === NAMESPACE[ i ].path ) {
			alias = NAMESPACE[ i ].alias;
			return alias;
		}
	}
	return null;
}


// MAIN //

/**
* Rule for enforcing that return annotation values mirror actual output.
*
* @param {Context} context - lint context
* @returns {Object} validators
*/
function main( context ) {
	/**
	* Checks whether return annotation values mirror actual output.
	*
	* @private
	* @param {Object} section - examples section
	*/
	function returnValues( section ) {
		var examples;
		var expected;
		var current;
		var pkgName;
		var actual;
		var match;
		var scope;
		var code;
		var msg;
		var pkg;
		var out;
		var key;
		var N;
		var o;
		var a;
		var b;
		var i;

		// FIXME: clean-up this logic

		if ( context.meta.filepath ) {
			expected = [];
			actual = [];
			pkg = dirname( dirname( context.meta.filepath ) );

			scope = {
				'setTimeout': setTimeout,
				'require': require
			};
			pkgName = pkg2alias( pkg ) || 'ALIAS';

			// TODO: use @stdlib/utils/deep-set once refactored!
			pkgName = pkgName.split( '.' );
			N = pkgName.length;
			o = scope;
			for ( i = 0; i < N; i++ ) {
				key = pkgName[ i ];
				if ( i < N-1 ) {
					if ( !hasOwnProp( o, key ) ) {
						o[ key ] = {};
					}
					o = o[ key ];
				} else {
					o[ key ] = require( pkg ); // eslint-disable-line stdlib/no-dynamic-require
				}
			}
			// TODO: process external aliases *BEFORE* creating the context (and also, what is going on here, given that the return value is ignored?)
			vm.createContext( scope );

			examples = section.examples;
			for ( i = 0; i < examples.length; i++ ) {
				current = examples[ i ];
				code = current.code;
				code = replace( code, '{{alias}}', pkgName.join( '.' ) );
				code = replace( code, RE_EXTERNAL_ALIAS, replaceAliases );
				try {
					out = vm.runInContext( code, scope );
					if ( current.output ) {
						expected.push( current.output );
						match = code.match( RE_ASSIGNMENT );
						if ( match && match[ 1 ] ) {
							actual.push( scope[ match[ 1 ] ] );
						} else {
							actual.push( out );
						}
					}
				} catch ( err ) {
					if ( current.output !== '<Error>' ) {
						context.report( 'Received an unexpected error when running example `'+code+'`: ' + err.message, section );
					}
				}
			}
			for ( i = 0; i < expected.length; i++ ) {
				a = actual[ i ];
				b = expected[ i ];
				msg = compareValues( a, b );
				if ( msg ) {
					context.report( msg, section );
				}
			}
		}

		/**
		* Replaces aliases to other packages in REPL example code and registers the respective packages in the runtime context.
		*
		* @private
		* @param {string} match - full match
		* @param {string} pkg - package path
		* @returns {string} variable name
		*/
		function replaceAliases( match, pkg ) {
			var alias;
			var key;
			var len;
			var o;
			var i;

			alias = pkg2alias( pkg );
			alias = alias.split( '.' );
			len = alias.length;

			// TODO: use @stdlib/utils/deep-set once refactored!
			o = scope;
			for ( i = 0; i < len; i++ ) {
				key = alias[ i ];
				if ( i < len-1 ) {
					if ( !hasOwnProp( o, key ) ) {
						o[ key ] = {};
					}
					o = o[ key ];
				} else {
					o[ key ] = require( pkg ); // eslint-disable-line stdlib/no-dynamic-require
				}
			}
			return alias.join( '.' );
		}
	}

	return {
		'examples': returnValues
	};
}


// EXPORTS //

module.exports = main;
