/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var exec = require( 'child_process' ).exec;
var join = require( 'path' ).join;
var logger = require( 'debug' );
var replace = require( '@stdlib/string/replace' );
var now = require( '@stdlib/time/now' );
var format = require( '@stdlib/string/format' );
var dirname = require( '@stdlib/utils/dirname' );
var EXEC_PATH = require( '@stdlib/process/exec-path' );
var parseConfig = require( './parse_config.js' );
var validate = require( './validate_config.js' );
var wrap = require( './module_wrap.js' );


// VARIABLES //

var debug = logger( 'remark-run-javascript-examples:transformer' );

// Regular expression to match comments which "disable" code block execution:
var RE_CONFIG_DISABLE = /^<!--\s+run-disable\s+-->$/;

// Regular expression to match configuration comments:
var RE_CONFIG = /^<!--\s+run\s+(.+)\s+-->$/;

// Raw HTML markers marking when an "examples" section begins and ends:
var EXAMPLES_BEGIN = '<section class="examples">';
var EXAMPLES_END = '<!-- /.examples -->';

// Raw HTML markers marking when a "usage" section begins and ends:
var USAGE_BEGIN = '<section class="usage">';
var USAGE_END = '<!-- /.usage -->';

// Regular expression to match a single trailing newline:
var RE_TRAILING_EOL = /\r?\n$/;

// Define a "virtual" filename for when provided a Markdown string, rather than file:
var TEMP_FILENAME_PREFIX = '__$in_memory_file_';

// `node` executable path:
var NODE = EXEC_PATH;


// MAIN //

/**
* Returns a transformer function.
*
* @private
* @param {Options} options - transformer options
* @param {boolean} options.quiet - boolean indicating whether to silence examples writing to `stdout`, but allow writing to `stderr`
* @param {boolean} options.silent - boolean indicating whether to silence examples writing to both `stdout` and `stderr`
* @param {boolean} options.verbose - boolean indicating whether to print plugin meta information
* @param {PositiveInteger} options.maxBuffer - maximum buffer size for `stdout` and `stderr`
* @param {NonNegativeInteger} options.timeout - maximum number of milliseconds allotted for the execution of each code block
* @param {string} [options.cwd] - current working directory of the child process
* @returns {Function} transformer function
*/
function factory( options ) {
	return transformer;

	/**
	* Transforms a Markdown abstract syntax tree (AST).
	*
	* @private
	* @param {Node} tree - root AST node
	* @param {File} file - virtual file
	* @param {Callback} clbk - callback to invoke upon completion
	* @returns {void}
	*/
	function transformer( tree, file, clbk ) {
		var FIRST;
		var fpath;
		var dpath;
		var total;
		var count;
		var UFLG;
		var EFLG;
		var dir;
		var idx;

		dir = options.cwd || file.dirname || file.cwd;
		debug( 'Execution directory: %s', dir );

		if ( file.path ) {
			// `remark` sets the file path relative to the current working directory, so we need to concatenate to resolve an absolute file path:
			fpath = join( file.cwd, file.path );
		} else {
			// Create a "virtual" file path:
			fpath = join( dir, TEMP_FILENAME_PREFIX+now().toString()+'__' );
		}
		dpath = dirname( fpath );
		debug( 'Processing file: %s', fpath );

		count = 0;
		idx = -1;
		total = tree.children.length;
		debug( '%d AST nodes.', total );

		if ( total === 0 ) {
			return done();
		}
		return next();

		/**
		* Processes the next AST node.
		*
		* @private
		* @returns {void}
		*/
		function next() {
			var script;
			var node;
			var opts;
			var prev;
			var conf;
			var cmd;
			var tmp;
			var err;
			var j;

			idx += 1;
			debug( 'Processing AST node %d of %d...', idx+1, total );

			node = tree.children[ idx ];
			debug( 'Node type: %s', node.type );

			if ( node.type === 'html' ) {
				if ( node.value === EXAMPLES_BEGIN ) {
					debug( 'Found an examples section.' );
					EFLG = true;
				} else if ( node.value === EXAMPLES_END ) {
					debug( 'Finished processing examples section.' );
					EFLG = false;
				} else if ( node.value === USAGE_BEGIN ) {
					debug( 'Found a usage section.' );
					FIRST = null;
					UFLG = true;
				} else if ( node.value === USAGE_END ) {
					debug( 'Finished processing usage section.' );
					UFLG = false;
				}
				return done();
			}
			if (
				( EFLG || UFLG ) &&
				node.type === 'code' &&
				( node.lang === 'javascript' || node.length === 'js' )
			) {
				debug( 'Found a JavaScript code block.' );
				count += 1;
				script = node.value;

				// Look for HTML comments immediately preceding a code block which may contain configuration...
				debug( 'Searching for a configuration comment...' );
				j = idx - 1;
				prev = tree.children[ j ];
				while ( prev && prev.type === 'html' ) {
					// Check for a configuration comment indicating that a code block should **not** be executed:
					if ( RE_CONFIG_DISABLE.test( prev.value ) ) {
						debug( 'Found a configuration comment disabling execution. Skipping code block...' );
						return done();
					}
					// Check for code block configuration:
					tmp = RE_CONFIG.exec( prev.value );
					if ( tmp ) {
						if ( conf ) {
							conf = tmp[ 1 ] + ', ' + conf;
						} else {
							conf = tmp[ 1 ];
						}
					}
					j -= 1;
					prev = tree.children[ j ];
				}
				debug( 'No configuration comment disabling execution found.' );

				// Parse code block configuration:
				if ( conf ) {
					debug( 'Parsing code block configuration...' );
					conf = parseConfig( conf );
					if ( conf instanceof Error ) {
						debug( 'Unable to parse code block configuration. Error: %s', conf.message );
						return done( conf );
					}
					debug( 'Validating code block configuration...' );
					err = validate( conf );
					if ( err instanceof Error ) {
						debug( 'Invalid code block configuration. Error: %s', err.message );
						return done( conf );
					}
				} else {
					conf = {};
				}
				debug( 'Code block configuration: %s', JSON.stringify( conf ) );

				// Escape single quotes (NOTE: bash escaping):
				script = replace( script, '\'', '\'"\'"\'' );

				// Check if this is the first block in a "usage" section...
				if ( UFLG ) {
					if ( FIRST === null ) {
						debug( 'Caching block contents...' );
						FIRST = '"use strict";\n\n' + script;
					} else {
						// Prepend the first block to all subsequent code blocks:
						script = FIRST + '\n\n' + script;
					}
				}
				// Wrap the script in a module wrapper:
				script = wrap( script, fpath, dpath );

				// Create the script command:
				cmd = [ NODE, '-e', '\''+script+'\'' ].join( ' ' );

				// Set the working directory of the script to the file directory:
				opts = {
					'cwd': conf.cwd || dir,
					'maxBuffer': conf.maxBuffer || options.maxBuffer,
					'timeout': (conf.timeout >= 0) ? conf.timeout : options.timeout
				};

				debug( 'Executing code block...' );
				if ( options.verbose ) {
					console.log( '\n---\nExecuting code block %d...\n', count ); // eslint-disable-line no-console
				}
				exec( cmd, opts, onExec );
			} else {
				return done();
			}

			/**
			* Callback invoked upon executing a code block.
			*
			* @private
			* @param {(Error|null)} error - error object
			* @param {Buffer} stdout - standard output
			* @param {Buffer} stderr - standard error
			* @returns {void}
			*/
			function onExec( error, stdout, stderr ) {
				if ( error ) {
					debug( 'Encountered an error when executing code block: %s', error.message );

					// Ensure that we don't return an error when the code block intentionally threw an exception...
					if ( !conf.throws ) {
						// TODO: the generated error is a bit messy. Cleaning-up may require manual modification of the stacktrace(s), etc.
						error = new Error( format( 'unexpected error. Encountered an error when executing code block. File: `%s`. Message: `%s`.', file.path || '(undefined)', error.message ) );
						return done( error );
					}
				} else if ( conf.throws ) {
					debug( 'Code block failed to throw an exception.' );
					error = new Error( format( 'unexpected error. Expected code block to throw an exception. File: `%s`.', file.path || '(undefined)' ) );
					return done( error );
				}
				if ( !options.quiet && !options.silent ) {
					stdout = stdout.toString();
					if ( stdout ) {
						// Trim off a trailing newline (e.g., prevent `console.log( console.log() )`:
						console.log( replace( stdout, RE_TRAILING_EOL, '' ) ); // eslint-disable-line no-console
					}
				}
				if ( !options.silent ) {
					stderr = stderr.toString();
					if ( stderr ) {
						// Trim off a trailing newline (e.g., prevent `console.error( console.error() )`:
						console.error( replace( stderr, RE_TRAILING_EOL, '' ) ); // eslint-disable-line no-console
					}
				}
				debug( 'Finished executing code block.' );
				done();
			}
		}

		/**
		* Callback invoked upon processing an AST node.
		*
		* @private
		* @param {Error} [error] - error object
		* @returns {void}
		*/
		function done( error ) {
			if ( error ) {
				return clbk( error );
			}
			debug( 'Processed %d of %d AST nodes.', idx+1, total );
			if ( idx === total-1 ) {
				debug( 'Finished processing file.' );
				return clbk();
			}
			next();
		}
	}
}


// EXPORTS //

module.exports = factory;
