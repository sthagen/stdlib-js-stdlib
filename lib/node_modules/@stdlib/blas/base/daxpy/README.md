<!--

@license Apache-2.0

Copyright (c) 2018 The Stdlib Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

-->

# daxpy

> Multiply `x` by a constant `alpha` and add the result to `y`.

<section class="usage">

## Usage

```javascript
var daxpy = require( '@stdlib/blas/base/daxpy' );
```

#### daxpy( N, alpha, x, strideX, y, strideY )

Multiplies `x` by a constant `alpha` and adds the result to `y`.

```javascript
var Float64Array = require( '@stdlib/array/float64' );

var x = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );
var y = new Float64Array( [ 1.0, 1.0, 1.0, 1.0, 1.0 ] );
var alpha = 5.0;

daxpy( x.length, alpha, x, 1, y, 1 );
// y => <Float64Array>[ 6.0, 11.0, 16.0, 21.0, 26.0 ]
```

The function has the following parameters:

-   **N**: number of indexed elements.
-   **alpha**: `numeric` constant.
-   **x**: input [`Float64Array`][mdn-float64array].
-   **strideX**: index increment for `x`.
-   **y**: input [`Float64Array`][mdn-float64array].
-   **strideY**: index increment for `y`.

The `N` and `stride` parameters determine which elements in `x` and `y` are accessed at runtime. For example, to multiply every other value in `x` by `alpha` and add the result to the first `N` elements of `y` in reverse order,

```javascript
var Float64Array = require( '@stdlib/array/float64' );
var floor = require( '@stdlib/math/base/special/floor' );

var x = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );
var y = new Float64Array( [ 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 ] );

var alpha = 5.0;
var N = floor( x.length / 2 );

daxpy( N, alpha, x, 2, y, -1 );
// y => <Float64Array>[ 26.0, 16.0, 6.0, 1.0, 1.0, 1.0 ]
```

Note that indexing is relative to the first index. To introduce an offset, use [`typed array`][mdn-typed-array] views.

<!-- eslint-disable stdlib/capitalized-comments -->

```javascript
var Float64Array = require( '@stdlib/array/float64' );
var floor = require( '@stdlib/math/base/special/floor' );

// Initial arrays...
var x0 = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );
var y0 = new Float64Array( [ 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );

// Create offset views...
var x1 = new Float64Array( x0.buffer, x0.BYTES_PER_ELEMENT*1 ); // start at 2nd element
var y1 = new Float64Array( y0.buffer, y0.BYTES_PER_ELEMENT*3 ); // start at 4th element

var N = floor( x0.length / 2 );

daxpy( N, 5.0, x1, -2, y1, 1 );
// y0 => <Float64Array>[ 7.0, 8.0, 9.0, 40.0, 31.0, 22.0 ]
```

#### daxpy.ndarray( N, alpha, x, strideX, offsetX, y, strideY, offsetY )

Multiplies `x` by a constant `alpha` and adds the result to `y` using alternative indexing semantics.

```javascript
var Float64Array = require( '@stdlib/array/float64' );

var x = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );
var y = new Float64Array( [ 1.0, 1.0, 1.0, 1.0, 1.0 ] );
var alpha = 5.0;

daxpy.ndarray( x.length, alpha, x, 1, 0, y, 1, 0 );
// y => <Float64Array>[ 6.0, 11.0, 16.0, 21.0, 26.0 ]
```

The function has the following additional parameters:

-   **offsetX**: starting index for `x`.
-   **offsetY**: starting index for `y`.

While [`typed array`][mdn-typed-array] views mandate a view offset based on the underlying `buffer`, the `offsetX` and `offsetY` parameters support indexing semantics based on starting indices. For example, to multiply every other value in `x` by a constant `alpha` starting from the second value and add to the last `N` elements in `y` where `x[i] -> y[n]`, `x[i+2] -> y[n-1]`,...,

```javascript
var Float64Array = require( '@stdlib/array/float64' );
var floor = require( '@stdlib/math/base/special/floor' );

var x = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );
var y = new Float64Array( [ 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );

var alpha = 5.0;
var N = floor( x.length / 2 );

daxpy.ndarray( N, alpha, x, 2, 1, y, -1, y.length-1 );
// y => <Float64Array>[ 7.0, 8.0, 9.0, 40.0, 31.0, 22.0 ]
```

#### daxpy.wasm( \[options] )

Returns a memory managed function to multiply `x` by a constant `alpha` and add the result to `y`.

```javascript
var Float64Array = require( '@stdlib/array/float64' );

var wasm = daxpy.wasm();

// Number of data elements:
var N = 5;

// Allocate space on the heap:
var xbytes = wasm.malloc( N * 8 ); // 8 bytes per double
var ybytes = wasm.malloc( N * 8 );

// Create Float64Array views:
var x = new Float64Array( xbytes.buffer, xbytes.byteOffset, N );
var y = new Float64Array( ybytes.buffer, ybytes.byteOffset, N );

// Copy data to the heap:
x.set( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );
y.set( [ 1.0, 1.0, 1.0, 1.0, 1.0 ] );

// Multiply and add:
var alpha = 5.0;
wasm( N, alpha, xbytes, 1, ybytes, 1 );
// y => <Float64Array>[ 6.0, 11.0, 16.0, 21.0, 26.0 ]

// Extract the results from the heap:
var r = new Float64Array( y.length );
var i;
for ( i = 0; i < y.length; i++ ) {
    r[ i ] = y[ i ];
}

// Free the memory:
wasm.free( xbytes );
wasm.free( ybytes );
```

For externally defined [typed arrays][mdn-typed-array], data must be copied to the heap.

```javascript
var Uint8Array = require( '@stdlib/array/uint8' );
var Float64Array = require( '@stdlib/array/float64' );

var wasm = daxpy.wasm();

// Number of data elements:
var N = 5;

// Externally defined data arrays:
var x = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0 ] );
var y = new Float64Array( [ 1.0, 1.0, 1.0, 1.0, 1.0 ] );

// Allocate space on the heap:
var xbytes = wasm.malloc( x.length * x.BYTES_PER_ELEMENT );
var ybytes = wasm.malloc( y.length * y.BYTES_PER_ELEMENT );

// Copy data to the heap:
xbytes.set( new Uint8Array( x.buffer ) );
ybytes.set( new Uint8Array( y.buffer ) );

// Multiply and add:
var alpha = 5.0;
wasm( N, alpha, xbytes, 1, ybytes, 1 );

// Extract the results from the heap:
var view = new Float64Array( ybytes.buffer, ybytes.byteOffset, y.length );
var i;
for ( i = 0; i < y.length; i++ ) {
    y[ i ] = view[ i ];
}
// y => <Float64Array>[ 6.0, 11.0, 16.0, 21.0, 26.0 ]

// Free the memory:
wasm.free( xbytes );
wasm.free( ybytes );
```

The method accepts the following `options`:

-   **memory**: total memory. If not provided a `buffer`, setting the `memory` option instructs the returned function to allocate an internal memory store of the specified size.
-   **stack**: total stack size. Must be less than the `memory` option and large enough for a program's needs. Default: `1024` bytes.
-   **buffer**: `ArrayBuffer` serving as the underlying memory store. If not provided, each returned function will allocate and manage its own memory. If provided a `memory` option, the buffer `byteLength` must equal the specified total memory.

To create a function using an externally defined memory buffer, set the `buffer` option.

<!-- FIXME: glue code seems to require more than just setting a `buffer` property: https://github.com/kripken/emscripten/blob/655cec1975e784985d25bc80c5438d715ac5ec13/src/preamble.js#L2155 and https://github.com/kripken/emscripten/blob/655cec1975e784985d25bc80c5438d715ac5ec13/src/preamble.js#L1141 -->

<!-- run-disable -->

```javascript
var ArrayBuffer = require( '@stdlib/array/buffer' );
var buffer = new ArrayBuffer( 16777216 ); // ~16MB

var wasm = daxpy.wasm({
    'buffer': buffer
});
```

Providing external memory can be advantageous when wanting to a) centrally manage memory allocation, b) share memory between multiple memory managed functions, and/or c) limit the total amount of allocated memory within an application or library. 

##### wasm.malloc( nbytes )

Allocates space on the heap and returns a bytes-wise [`typed array`][mdn-typed-array] view ([`Uint8Array`][mdn-uint8array]).

```javascript
var wasm = daxpy.wasm();

// Allocate 64 bytes:
var bytes = wasm.malloc( 64 );
```

##### bytes.getValue( ptr\[, type] )

Returns a value at a specific memory address (represented by a byte index). By default, the function returns a `double`. Possible types include: `'i8'`, `'i16'`, `'i32'`, `'i64'`, `'float'`, and `'double'`.

```javascript
var Float64Array = require( '@stdlib/array/float64' );

var wasm = daxpy.wasm();

var N = 3;

var bytes = wasm.malloc( N * 8 );
var view = new Float64Array( bytes.buffer, bytes.byteOffset, N );

view.set( [ 1.0, -2.0, 3.0 ] );

var ptr = 1 * 8; // 8 bytes per double
var y = bytes.getValue( ptr );
// returns -2.0

wasm.free( bytes );
```

While this method may be convenient when interacting with the bytes view directly, using a [`typed array`][mdn-typed-array] view is likely to be more performant.

```javascript
var Float64Array = require( '@stdlib/array/float64' );

var wasm = daxpy.wasm();

var N = 3;

var bytes = wasm.malloc( N * 8 );
var view = new Float64Array( bytes.buffer, bytes.byteOffset, N );

view.set( [ 1.0, -2.0, 3.0 ] );

var y = view[ 1 ];
// returns -2.0

wasm.free( bytes );
```

##### bytes.setValue( ptr, value\[, type] )

Sets a value at a specific memory address (represented by a byte index). By default, the function sets a `double`. Possible types include: `'i8'`, `'i16'`, `'i32'`, `'i64'`, `'float'`, and `'double'`.

```javascript
var Float64Array = require( '@stdlib/array/float64' );

var wasm = daxpy.wasm();

var N = 3;

var bytes = wasm.malloc( N * 8 );
var view = new Float64Array( bytes.buffer, bytes.byteOffset, N );

view.set( [ 1.0, -2.0, 3.0 ] );

var ptr = 1 * 8; // 8 bytes per double
var y = bytes.getValue( ptr );
// returns -2.0

bytes.setValue( ptr, -10.0 );

y = bytes.getValue( ptr );
// returns -10.0

wasm.free( bytes );
```

While this method may be convenient when interacting with the bytes view directly, using a [`typed array`][mdn-typed-array] view is likely to be more performant.

```javascript
var Float64Array = require( '@stdlib/array/float64' );

var wasm = daxpy.wasm();

var N = 3;

var bytes = wasm.malloc( N * 8 );
var view = new Float64Array( bytes.buffer, bytes.byteOffset, N );

view.set( [ 1.0, -2.0, 3.0 ] );

var y = view[ 1 ];
// returns -2.0

view[ 1 ] = -10.0;

y = view[ 1 ];
// returns -10.0

wasm.free( bytes );
```

##### wasm.free( heap )

Frees allocated space.

```javascript
var wasm = daxpy.wasm();

var bytes = wasm.malloc( 64 );

// ...

// Free the space and allow reallocation:
wasm.free( bytes );
```

</section>

<!-- /.usage -->

<section class="notes">

## Notes

-   If `N <= 0` or `alpha == 0`, both functions return `y` unchanged.
-   `daxpy()` corresponds to the [BLAS][blas] level 1 function [`daxpy`][daxpy].

</section>

<!-- /.notes -->

<section class="examples">

## Examples

<!-- eslint no-undef: "error" -->

```javascript
var randu = require( '@stdlib/random/base/randu' );
var round = require( '@stdlib/math/base/special/round' );
var Float64Array = require( '@stdlib/array/float64' );
var daxpy = require( '@stdlib/blas/base/daxpy' );

var x;
var y;
var i;

x = new Float64Array( 10 );
y = new Float64Array( 10 );
for ( i = 0; i < x.length; i++ ) {
    x[ i ] = round( randu() * 100.0 );
    y[ i ] = round( randu() * 10.0 );
}
console.log( x );
console.log( y );

daxpy.ndarray( x.length, 5.0, x, 1, 0, y, -1, y.length-1 );
console.log( y );
```

</section>

<!-- /.examples -->

<section class="links">

[blas]: http://www.netlib.org/blas

[daxpy]: http://www.netlib.org/lapack/explore-html/de/da4/group__double__blas__level1.html

[mdn-float64array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array

[mdn-typed-array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray

[mdn-uint8array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array

</section>

<!-- /.links -->
